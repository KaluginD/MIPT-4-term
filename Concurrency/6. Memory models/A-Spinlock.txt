// Test-And-Set spinlock
class TASSpinLock {
public:
    void Lock() {
        while (locked_.exchange(true /*, memory order */)) {
            std::this_thread::yield();
        }
    }

    void Unlock() {
        locked_.store(false /*, memory order */);
    }

private:
    std::atomic<bool> locked_{false};
};

1. Объяснить, какие неатомарные чтения и записи и зачем должны быть упорядочены.
Критические секции должны быть упорядочены с порядком happens-before. Внутри каждой критической секции должны быть упорядочены неатомарные записи. 

2. Показать, как алгоритм гарантирует возникновение стрелок  happens-before между нужными чтениями и записями.
За упорядочивание критических секций отвечает атомарный флаг locked_. На чтениях/записях в него гарантирается отношение synchronization order. Вместе с порядком program-order в каждом из потоков они гарантируют возниконовение стрелок happens-before между операциями до обращения к флагу и после.
 
3. Максимально ослабить гарантии упорядочивания.
Очевидно, что если взять Relaxed, у нас уже не будет точки синхронизации.
Так как у нас только один atomic, можно использовать Acquire/Release.
